using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Animations;
using Sirenix.OdinInspector;
using System.Linq;

namespace TowerTanks.Scripts
{
    /// <summary>
    /// Square component which rooms are made of.
    /// </summary>
    public class Cell : MonoBehaviour, IDamageable, IBurnable
    {
        //Static Variables:
        public static Vector2[] cardinals = { Vector2.up, Vector2.right, Vector2.down, Vector2.left };

        //Objects & Components:
        internal BoxCollider2D c;              //Cell's local collider
        internal Room room;                    //The room this cell is a part of.
        internal BoxCollider2D compositeClone; //Duplicate of this cell's collider which is installed in treadSystem object and provides collision (destroyed when this cell is destroyed) (generated by rooms when attaching to tank)
        /// <summary>
        /// Array of up to four cells which directly neighbor this cell.
        /// Includes cells in other rooms.
        /// Order is North (0), West (1), South (2), then East (3).
        /// </summary>
        public Cell[] neighbors = new Cell[4];
        /// <summary>
        /// Array of up to four optional connector (spacer) pieces which attach this cell to its corresponding neighbor.
        /// Connectors indicate splits between room sections.
        /// </summary>
        public Connector[] connectors = new Connector[4]; //Connectors adjacent to this cell (in NESW order)
        /// <summary>
        /// Couplers adjacent to this cell (connected couplers will modify cell walls).
        /// </summary>
        public List<Coupler> couplers = new List<Coupler>();
        /// <summary>
        /// Spriterenders for displaying corners of cell walls (in NW, NE, SE, SW order).
        /// </summary>

        //UI
        internal SpriteRenderer damageSprite;
        internal Animator cellAnimator;

        [Header("Cell Components:")]
        [Tooltip("Back wall of cell, will be turned into sprite mask by room kit.")]                public GameObject backWall;
        [Tooltip("Pre-assigned cell walls (in NESW order) which confine players inside the tank.")] public GameObject[] walls;
        [Tooltip("Points at corners of cell's outer wall, used to generate wall.")]                 public Transform[] corners = new Transform[4];
        [Tooltip("Mask used to hide cell walls when cell is destroyed.")]                           private GameObject deathWallMask;
        [Space()]
        [SerializeField, Tooltip("The interactable currently installed in this cell (if any).")]      internal TankInteractable interactable;
        [SerializeField, Tooltip("Transform used for repairmen to snap to when repairing this cell")] public Transform repairSpot;
        [SerializeField, Tooltip("The character currently repairing this cell")]                      public GameObject repairMan;
        [SerializeField, Tooltip("Sprites used for showing damage on the cell")]                      public SpriteRenderer[] diageticDamageSprites;
        public enum TankPosition { TOP = 1, BOTTOM = -1 };

        //Settings:
        [Button("Debug Destroy Cell")] public void DebugDestroyCell() { Kill(); }
        [Button("Debug Pull Cell")] public void DebugPullCell() { Pull(); }
        [Button("Debug Damage Cell")] public void DebugDamageCell() { Damage(50f); }

        //Runtime Variables:
        //Gameplay:
        [Tooltip("Maximum hitpoints this cell can have when fully repaired.")] public float maxHealth;
        [InlineButton("RepairCell", SdfIconType.Wrench, "")]
        [Tooltip("Current hitpoints this cell has.")]                          public float health;
        [Tooltip("Which section this cell is in inside its parent room.")]     internal int section;
        [Tooltip("How long damage visual effect persists for")]                private float damageTime;
        private float damageTimer;

        //Fire:
        [Tooltip("Whether or not This Is Fine")]                               public bool isOnFire;
        [Tooltip("Rate at which fire damages this cell")]                      private float burnDamageRate = 0.5f;
                                                                            private float burnDamageTimer = 0;
        [Tooltip("Max time before fire spreads to a neighboring cell")]        private float maxBurnTime = 8f;
        [Tooltip("Max time before fire spreads to a neighboring cell")]        private float minBurnTime = 6f;
        private float burnTimer = 0;
        public GameObject flames;
        //Meta
        [Tooltip("True if cell destruction has already been scheduled, used to prevent conflicts.")]                private bool dying;
        [Tooltip("True once cell has been set up and is ready to go.")]                                             private bool initialized = false;
        [Tooltip("Player which is currently building an interactable in this cell.")]                               internal PlayerMovement playerBuilding;
        [Tooltip("Cell's position in parent room manifest, used to indicate which cells in a room are destroyed.")] internal int manifestIndex;

        //RUNTIME METHODS:
        private void Awake()
        {
            Initialize(); //Set up cell
        }

        private void Start()
        {
            //Assign Values
            if (room.type == Room.RoomType.Armor) maxHealth += 25f; //Armor has +25 hitpoints
            health = maxHealth;
        }

        private void Update()
        {
            /*if (damageTimer > 0)
            {
                UpdateUI();
            }
            */

            if (isOnFire)
            {
                Burn();
            }
        }
        private void OnDestroy()
        {
            Destroy(backWall); //Make sure back wall gets destroyed when cell is destroyed
        }
        
        //RUNTIME METHODS:
        private void UpdateUI()
        {
            /*//Flash Effect
            Color newColor = damageSprite.color;
            newColor.a = Mathf.Lerp(0, 255f, (damageTimer / damageTime) * Time.deltaTime);
            damageSprite.color = newColor;

            damageTimer -= Time.deltaTime;
            if (damageTimer < 0)
            {
                damageTimer = 0;
                damageTime = 0;
            }
            */

            //Diagetic Damage Sprites
            if (health < maxHealth)
            {
                diageticDamageSprites[0].enabled = true;

                if (health <= (maxHealth * 0.75f)) { diageticDamageSprites[1].enabled = true; }
                else diageticDamageSprites[1].enabled = false;

                if (health <= (maxHealth * 0.5f)) { diageticDamageSprites[2].enabled = true; }
                else diageticDamageSprites[2].enabled = false;

                if (health <= (maxHealth * 0.25f)) { diageticDamageSprites[3].enabled = true; }
                else diageticDamageSprites[3].enabled = false;
            }
            else
            {
                foreach (SpriteRenderer sprite in diageticDamageSprites)
                {
                    sprite.enabled = false;
                }
            }
        }

        //FUNCTIONALITY METHODS:
        /// <summary>
        /// Performs all necessary setup so that cell is ready to use.
        /// </summary>
        public void Initialize()
        {
            //Initialization check:
            if (initialized) return; //Do not attempt to re-initialize cell
            initialized = true;      //Indicate that cell has been initialized

            //Get objects & components:
            room = GetComponentInParent<Room>(); //Get room cell is connected to
            c = GetComponent<BoxCollider2D>();   //Get local collider
            health = maxHealth;
            damageSprite = transform.Find("DiageticUI")?.GetComponent<SpriteRenderer>();
            deathWallMask = transform.Find("DeathWallMask").gameObject;                  //Get object used to mask out cell walls in death
            cellAnimator = GetComponent<Animator>();
        }
        /// <summary>
        /// Updates list indicating which sides are open and which are adjacent to other cells.
        /// </summary>
        /// <param name="excludeExternal">If true, cell will ignore cells from other rooms.</param>
        public void UpdateAdjacency(bool excludeExternal = true)
        {
            //Get new neighbors:
            for (int x = 0; x < 4; x++) //Loop for four iterations (once for each direction)
            {
                if (neighbors[x] != null) continue; //Don't bother checking directions which are already occupied by neighbors
                List<RaycastHit2D> hits = Physics2D.RaycastAll(transform.position, cardinals[x], 1, (LayerMask.GetMask("Cell") | LayerMask.GetMask("Connector"))).ToList(); //Check for adjacent cell in given direction
                foreach (RaycastHit2D hit in hits) //Iterate through hit objects
                {
                    //Update neighbors:
                    if (hit.collider.TryGetComponent(out Cell cell) && hit.collider != c) //Adjacent cell found in current direction
                    {
                        if (excludeExternal && hit.transform.parent != transform.parent) continue; //If told to, ignore cells which don't share a parent with this cell
                        neighbors[x] = cell;                                  //Indicate that cell is a neighbor
                        neighbors[x].neighbors[(x + 2) % 4] = this;           //Let neighbor know it has a neighbor (coming from the opposite direction)
                        walls[x].SetActive(false);                            //Disable wall facing neighbor
                        neighbors[x].walls[(x + 2) % 4].SetActive(false);     //Disable neighbor's wall facing this cell
                        neighbors[x].connectors[(x + 2) % 4] = connectors[x]; //Update neighbor on known connector status
                    }
                }
                foreach (RaycastHit2D hit in hits) //Iterate through remaining hit objects (now that neighbors have been populated)
                {
                    //Update connectors:
                    if (hit.transform.GetComponentInParent<Connector>() != null) //Adjacent connector found in current direction
                    {
                        //Connector updates:
                        Connector connector = hit.transform.GetComponentInParent<Connector>(); //Get found connector object
                        if (connector.room != room) continue;                                  //Skip connectors from other rooms
                        connectors[x] = connector;                                             //Save information about connector to slot in current direction
                        connector.cellA = this;                                                //Indicate to connector that it is attached to this cell
                        if (x == 0 || x == 2) connector.vertical = true;                       //If connector is between two vertically-oriented cells, indicate that it is vertical
                        else connector.vertical = false;                                       //Otherwise, indicate connector is horizontal

                        //Neighbor updates:
                        if (neighbors[x] != null) //Neighbor is present on other side of connector
                        {
                            neighbors[x].connectors[(x + 2) % 4] = connector; //Give connection information to neighbor
                            connector.cellB = neighbors[x];                   //Indicate to connector that it is attached to neighbor
                        }
                    }
                }
            }
        }
        /// <summary>
        /// Resets adjacency data (must be done to all cells before re-updating adjacency to prevent bugs).
        /// </summary>
        public void ClearAdjacency()
        {
            neighbors = new Cell[4];                                 //Clear neighbors
            connectors = new Connector[4];                           //Clear connectors
            foreach (GameObject wall in walls) wall.SetActive(true); //Reset walls
        }
        /// <summary>
        /// Processor for damaging cell with a projectile impact.
        /// </summary>
        /// <param name="projectile">Projectile which is doing damage to this cell.</param>
        /// <param name="position">Position of impact.</param>
        /// <returns>Returns leftover damage from impact (if projectile destroys cell).</returns>
        public float Damage(Projectile projectile, Vector2 position)
        {
            //Do projectile impact:
            room.targetTank.treadSystem.HandleImpact(projectile, position); //Use treadsystem impact handler to calculate impact force from projectile
            float animSpeed = 1;

            //Do hit effects:
            if (projectile.type == Projectile.ProjectileType.SHELL)
            {
                GameManager.Instance.AudioManager.Play("ShellImpact", gameObject); //Play impact sound
                animSpeed = 0.5f;
            }
            else if (projectile.type == Projectile.ProjectileType.BULLET)
            {
                GameManager.Instance.AudioManager.Play("BulletImpact", gameObject); //Play impact sound
                animSpeed = 4f;
            }

            //Deal damage:
            if (room.isCore || room.targetTank.isFragile) //Projectile has struck a core cell, or the tank is fragile
            {
                Damage(projectile.remainingDamage); //Simply do normal projectile damage to the core
                return 0;                           //Projectiles cannot tunnel through the core
            }
            else //Projectile has struck a non-core room
            {
                //Get damage values:
                float incomingDamage = projectile.remainingDamage;                                                        //Get remaining damage from projectile as value to assign to damaging cell
                float damageMitigated = Mathf.Min(GetDamageMitigation(incomingDamage), incomingDamage);                   //Determine amount of damage mitigated by cell attributes
                float dealtDamage = incomingDamage - damageMitigated;                                                     //Determine the amount of unmitigated damage dealt to cell
                float extraDamage = projectile.hitProperties.tunnels ? Mathf.Abs(Mathf.Max(0, health - dealtDamage)) : 0; //Get overkill damage dealt by projectile (only if projectile can tunnel, otherwise alsways destroy it after hitting a cell)

                //Effects
                if (dealtDamage > 0) HitEffects(animSpeed);
                else HitEffects(8f);

                //Cleanup:
                Damage(dealtDamage); //Assign dealt damage to cell (add armor-mitigated damage back because it needs to be processed in the damage method as well in case of explosions)
                return extraDamage;  //Tell the projectile how much left over damage it has
            }
        }
        /// <summary>
        /// Simply deals given amount of damage to cell (used for non-projectile damage, ALWAYS IGNORES ARMOR).
        /// </summary>
        public void Damage(float damage, bool triggerHitEffect = false)
        {
            //If the current scene is the build scene, return
            if (GameManager.Instance.currentSceneState == SCENESTATE.BuildScene)
                return;

            if (room.isCore || room.targetTank.isFragile) //Damage is being dealt to core cell
            {
                if (!room.targetTank.isInvincible) room.targetTank.Damage(damage); //Deal all core cell damage directly to tank instead of destroying cells (unless tank is invincible)
            }
            else //Damage is being dealt to normal cell
            { 
                //Deal damage:
                health = Mathf.Max(0, health - damage); //Deal damage to cell
                if (health <= 0) Kill();                //Kill cell if mortal damage has been dealt
                else if (triggerHitEffect)
                {
                    if (damage > 20) HitEffects(0.5f);
                    else HitEffects(4f);
                }
            }
        }

        public void HitEffects(float speedScale)
        {
            UpdateUI();
            cellAnimator.SetFloat("SpeedScale", speedScale);
            cellAnimator.Play("DamageFlash", 0, 0);
        }

        /*
        /// <summary>
        /// Deals given amount of damage to the cell (used for non-projectile damage).
        /// </summary>
        public float Damage(float amount, bool ignoreArmor = false)
        {
            float tempHealth = health;
            float healthLost = 0;

            if (room.isCore)
            {
                if (room.targetTank.isInvincible == false) {
                    room.targetTank.Damage(amount);
                }
            }
            else
            {
                if (room.type == Room.RoomType.Armor && ignoreArmor == false) amount -= 25f; //Armor reduces incoming damage
                
                if (amount <= 0) { amount = 1; }
                if (room.targetTank.isInvincible) { amount = 0; }
                else
                {
                    float damageTimeAdd = (amount / 50f);
                    if (damageTimeAdd < 0.1f) damageTimeAdd = 0.1f;
                    damageTime += damageTimeAdd;
                    damageTimer = damageTime;
                }
                
                health -= amount;

                if (health < 0) health = 0;
                healthLost = tempHealth - health;
                if (room.type == Room.RoomType.Armor) healthLost += 25f;

                if (health <= 0) Kill();
            }

            return healthLost;
        }
        */
        /// <summary>
        /// Checks to see if this cell has been disconnected from the tank and then kills it if it has been.
        /// </summary>
        public void KillIfDisconnected()
        {
            //Validity checks:
            if (dying) return; //Do not try to kill a cell twice

            //Check connection:
            List<Cell> connectedCells = new List<Cell>(); //Initialize a list to store cells found to be connected to this cell
            connectedCells.Add(this);                     //Seed list with this cell
            for (int y = 0; y < connectedCells.Count; y++) //Iterate through list of cells connected to detached neighbor, populating as we go
            {
                //Check cell identity:
                Cell currentCell = connectedCells[y]; //Get current cell
                if (currentCell.room.isCore) return; //Abort if cell chain is connected to core

                //Populate neighbor list:
                for (int z = 0; z < 4; z++) //Iterate through neighbors of connected cell
                {
                    Cell neighbor = currentCell.neighbors[z];                                                 //Get current neighbor
                    if (neighbor != null && !connectedCells.Contains(neighbor)) connectedCells.Add(neighbor); //Add neighbor if it isn't already found in list
                }
                foreach (Coupler coupler in currentCell.couplers) //Iterate through couplers connected to current cell
                {
                    Cell couplerNeighbor = coupler.GetOtherCell(currentCell);                                                      //Get neighbor through coupler
                    if (couplerNeighbor != null && !connectedCells.Contains(couplerNeighbor)) connectedCells.Add(couplerNeighbor); //Add neighbor if it isn't already found in list
                }
            }

            //(RYAN) Here's where I want it to check whether or not this cell's parent room is still connected to the tank.
            //If it is:
            Kill(); //Kill cell if it has not found a connection to the core
            //If it isn't: {
            //if (Room.tank.corpseInstance == null) Room.Tank.GenerateCorpse();
            //Room.MakeDummy(Room.tank.corpseInstance.transform); }
        }
        /// <summary>
        /// Obliterates cell and updates adjacency info for other cells.
        /// </summary>
        /// <param name="proxy">Pass true when cell is being destroyed by another cell destruction method.</param>
        /// <param name="spareIfConnected">If true, cell will only be destroyed if it is currently disconnected from the rest of the tank.</param>
        public void Kill(bool proxy = false)
        {
            //Validity checks:
            if (room.isCore) return; //Do not allow cells in core room to be destroyed
            if (dying) return;       //Do not try to kill a cell twice (happens in certain edge cases)
            dying = true;            //Indicate that cell is now dying

            //Adjacency cleanup:
            List<Cell> detachedNeighbors = new List<Cell>(); //Create list to store neighbors which have been detached from this cell
            for (int x = 0; x < 4; x++) //Iterate through neighbor and connector array
            {
                if (neighbors[x] != null) //Cell has a neighbor in this direction
                {
                    neighbors[x].neighbors[(x + 2) % 4] = null; //Clear neighbor reference to this cell
                    detachedNeighbors.Add(neighbors[x]);        //Add neighbor to list of detached cells
                }
            }
            for (int x = 0; x < couplers.Count; x++) //Iterate through couplers adjacent to cell
            {
                detachedNeighbors.Add(couplers[x].GetOtherCell(this)); //Get cell on other side of coupler and add to detached neighbor list
                                                                       //NOTE: Delete floating couplers
            }

            //Breakoff detection:
            if (!proxy && detachedNeighbors.Count > 0) //Cells being destroyed by breakoff calculation of another cell do not need to do their own calculation
            {
                for (int x = 0; x < detachedNeighbors.Count;) //Iterate until at the end of detached neighbors list (list may be edited mid-iteration)
                {
                    List<Cell> connectedCells = new List<Cell>(); //Initialize a list to store cells found to be connected to detached cell
                    connectedCells.Add(detachedNeighbors[x]);     //Seed list with cell from detached neighbors list
                    for (int y = 0; y < connectedCells.Count; y++) //Iterate through list of cells connected to detached neighbor, populating as we go
                    {
                        //Check cell identity:
                        Cell currentCell = connectedCells[y]; //Get current cell
                        if (currentCell.room.isCore) //Core room has been found, neighborhood will not be detached
                        {
                            foreach (Cell cell in connectedCells) if (detachedNeighbors.Contains(cell)) detachedNeighbors.Remove(cell); //Remove all cells in found neighborhood from potential detachments list (because they are safely connected)
                            connectedCells.Clear();                                                                                     //Clear neighborhood list to indicate that none of these cells should be destroyed
                            break;                                                                                                      //Break neighborhood population loop and continue to other direct neighbors of destroyed cell
                        }

                        //Populate neighbor list:
                        for (int z = 0; z < 4; z++) //Iterate through neighbors of connected cell
                        {
                            Cell neighbor = currentCell.neighbors[z];                                                 //Get current neighbor
                            if (neighbor != null && !connectedCells.Contains(neighbor)) connectedCells.Add(neighbor); //Add neighbor if it isn't already found in list
                        }
                        foreach (Coupler coupler in currentCell.couplers) //Iterate through couplers connected to current cell
                        {
                            Cell couplerNeighbor = coupler.GetOtherCell(currentCell);                                                      //Get neighbor through coupler
                            if (couplerNeighbor != null && !connectedCells.Contains(couplerNeighbor)) connectedCells.Add(couplerNeighbor); //Add neighbor if it isn't already found in list
                        }
                    }

                    //Neighborhood destruction:
                    if (connectedCells.Count > 0) //Neighborhood is no longer connected to tank base
                    {
                        detachedNeighbors.RemoveAt(x);        //Indicate that this neighborhood has been dealt with
                        foreach (Cell cell in connectedCells) //Iterate through each cell in disconnected neighborhood
                        {
                            //(Ryan) Add Dummy Logic here
                            cell.Kill(true); //Destroy cell (proxy setting prevents them from each having to separately check for breakoff)
                        }
                    }
                }
            }

            //Non-object cleanup:
            foreach (Connector connector in connectors) { if (connector != null) connector.Damage(this); } //Indicate to each attached connector that cell has been destroyed
            while (couplers.Count > 0) //Destroy connected couplers until none are left
            {
                Coupler coupler = couplers[0];                            //Get reference to target coupler
                if (coupler != null) coupler.Kill();                      //Destroy target coupler (it should remove itself from coupler list here
                if (couplers.Contains(coupler)) couplers.Remove(coupler); //Make SURE coupler has been removed from list
            }
            if (playerBuilding) playerBuilding.StopBuilding(); //Force player to stop building if a player is building in this cell

            //Room cleanup:
            room.cells.Remove(this);                                   //Remove this cell from room cell list
            if (!proxy) room.targetTank.treadSystem.ReCalculateMass(); //Re-calculate tank mass based on new cell configuration (only needs to be done once for group cell destructions)

            //Cleanup:
            Character[] characters = GetComponentsInChildren<Character>();
            if (characters.Length > 0)
            {
                foreach (Character character in characters)
                {
                    character.transform.parent = null; // removes the player from the cell before destruction if present
                    if (!proxy) character.KillCharacterImmediate();
                }
            }
            CleanUpCollision();                 //Remove cell collision
            AddInteractablesFromCell();         //Add cell interactables to stack
            room.targetTank.UpdateSizeValues(false); //Update highest cell tracker

            //Update walls:
            deathWallMask.transform.parent = room.outerWallController.transform; //Child death mask to the wall spriteRenderer which it will be masking out
            deathWallMask.SetActive(true);                                       //Activate mask

            //Update Room Status:
            room.cells.Remove(this);                  //Remove this cell from parent room's list of cells
            room.cellManifest[manifestIndex] = false; //Indicate to room that this cell is missing and should be saved as such
            if (room.cells.Count <= 0) //Parent room now has no cells
            {
                room.targetTank.rooms.Remove(room); //Remove room from parent tank's list of rooms
                Destroy(room.gameObject);           //Destroy room (simple because it is composed of no cells)
            }
            Destroy(gameObject); //Destroy this cell

            //Other Effects:
            GameManager.Instance.AudioManager.Play("MedExplosionSFX", gameObject);
            GameManager.Instance.ParticleSpawner.SpawnParticle(5, transform.position, 0.15f, null);
        }
        /// <summary>
        /// Removes the interactables from a player tank's cell and returns them to the stack.
        /// </summary>
        public void AddInteractablesFromCell()
        {
            //Stack update:
            if (interactable != null && interactable.interactableType != TankInteractable.InteractableType.CONSUMABLE)
            {
                if (room.targetTank != null && room.targetTank.tankType == TankId.TankType.PLAYER) StackManager.AddToStack(GameManager.Instance.TankInteractableToEnum(interactable)); //Add interactable data to stack upon destruction (if it is in a player tank)
                Destroy(interactable.gameObject); //Destroy this interactable
            }
        }

        /// <summary>
        /// Simply removes cell without going through all the destruction rigamarole. Mainly meant for removing cells from rooms upon automatic construction of tank from build settings.
        /// </summary>
        public void Pull()
        {
            //Update walls:
            deathWallMask.transform.parent = room.outerWallController.transform; //Child death mask to the wall spriteRenderer which it will be masking out
            deathWallMask.SetActive(true);                                       //Activate mask

            //Update everything else:
            room.cells.Remove(this); //Take this cell out of its parent room's list
            CleanUpCollision();      //Clean up collision elements
            for (int x = 0; x < connectors.Length; x++) //Iterate through list of connectors (all need to be destroyed)
            {
                //Destroy connectors:
                if (connectors[x] == null) continue;                             //Skip empty connector slots
                Cell otherCell = connectors[x].GetOtherCell(this);               //Get neighbor on other side of connector from this cell
                if (otherCell != null) otherCell.connectors[(x + 2) % 4] = null; //Remove neighbor's reference to this connector if applicable
                Destroy(connectors[x].gameObject);                               //Destroy connector
                connectors[x] = null;                                            //Clear reference to destroyed connector

                //Add wall cap:
                Transform wallCap = Instantiate(Resources.Load<GameObject>("TankPrefabs/WallCap").transform); //Instantiate a wall cap visual to put over hole created by pulling connector
                wallCap.parent = otherCell.transform;                                                         //Child cap to relevant cell
                wallCap.transform.position = otherCell.walls[(x + 2) % 4].transform.position;                 //Match cap position to wall position
                wallCap.transform.localScale = Vector3.one;                                                   //Clean up local scale
                wallCap.transform.Rotate(Vector3.forward, 180 - 90 * x);                                      //Rotate cap to match direction of wall opening
            }
            for (int x = 0; x < neighbors.Length; x++) //Iterate through list of neighbors (all need to be updated)
            {
                //Reactivate neighbor wall:
                if (neighbors[x] == null) continue;              //Skip empty neighbor slots
                neighbors[x].neighbors[(x + 2) % 4] = null;      //Clear neighbor reference to this cell
                neighbors[x].walls[(x + 2) % 4].SetActive(true); //Re-activate neighbor's wall facing this cell

                //Add wall cap:
                Transform wallCap = Instantiate(Resources.Load<GameObject>("TankPrefabs/WallCap").transform); //Instantiate a wall cap visual to put over hole created by pulling connector
                wallCap.parent = neighbors[x].transform;                                                      //Child cap to relevant cell
                wallCap.transform.position = neighbors[x].walls[(x + 2) % 4].transform.position;              //Match cap position to wall position
                wallCap.transform.localScale = Vector3.one;                                                   //Clean up local scale
                wallCap.transform.Rotate(Vector3.forward, 180 - 90 * x);                                      //Rotate cap to match direction of wall opening
            }
            while (couplers.Count > 0) //Iterate until there are no couplers left on this cell
            {
                Coupler coupler = couplers[0]; //Get coupler from list
                couplers.RemoveAt(0);          //Remove coupler from list
                coupler.Kill(true);            //Kill coupler non-destructively
            }
            Destroy(gameObject); //Destroy cell once pulled
        }

        private void RepairCell()
        {
            Repair(25);
        }

        public void Repair(float amount)
        {
            if (health < maxHealth)
            {
                health += amount;
                HitEffects(1.5f);
                GameManager.Instance.AudioManager.Play("UseWrench", gameObject);
                GameManager.Instance.ParticleSpawner.SpawnParticle(6, transform.position, 0.25f, null);
                GameManager.Instance.ParticleSpawner.SpawnParticle(7, transform.position, 0.25f, null);
            }

            if (health > maxHealth) { health = maxHealth; }
        }

        [Button("Ignite")]
        public void Ignite()
        {
            isOnFire = true;
            flames.SetActive(true);
            burnDamageTimer = burnDamageRate;
            burnTimer = Random.Range(minBurnTime, maxBurnTime);

            GameManager.Instance.AudioManager.Play("CoalLoad", this.gameObject);
        }
        public void BurnTick(float deltaTime)
        {

        }

        private void Burn()
        {
            burnDamageTimer -= Time.deltaTime;

            //Check to See if there's an Engine in the Cell
            EngineController engine = interactable?.gameObject.GetComponent<EngineController>();

            if (burnDamageTimer <= 0)
            {
                burnDamageTimer = burnDamageRate;

                if (health >= maxHealth * 0.25f) Damage(5f);

                if (interactable != null)
                {
                    if (engine != null) engine.AddPressure(10, false, true);
                }

                //Check for Characters in Cell
                Character[] characters = GetComponentsInChildren<Character>();
                if (characters.Length > 0)
                {
                    foreach (Character character in characters)
                    {
                        int igniteChance = Random.Range(40, 61);
                        int randomRoll = Random.Range(0, 100);
                        if (randomRoll <= igniteChance) {
                            if (character.isOnFire == false)
                            {
                                character.Ignite();
                            }
                        }

                    }
                }
            }

            burnTimer -= Time.deltaTime;
            if (burnTimer <= 0)
            {
                //Reset Timer
                float burnTimeMult = 1.5f;
                burnTimer = Random.Range(minBurnTime * burnTimeMult, maxBurnTime * burnTimeMult);

                //Destroy Cell Contents
                if (interactable != null)
                {
                    if (engine != null)
                    {
                        engine.Explode();
                    }
                    else
                    {
                        if (room.targetTank != null && room.targetTank.tankType == TankId.TankType.PLAYER) StackManager.AddToStack(GameManager.Instance.TankInteractableToEnum(interactable)); //Add interactable data to stack upon destruction (if it is in a player tank)
                        interactable.DebugDestroy();
                    }

                    GameManager.Instance.ParticleSpawner.SpawnParticle(0, transform.position, 0.15f, null);
                    GameManager.Instance.AudioManager.Play("ExplosionSFX", gameObject);
                }


                //Try to Spread Fire
                List<Cell> flammables = new List<Cell>();

                foreach(Cell neighbor in neighbors) //Find potential spread targets
                {
                    if (neighbor != null)
                    {
                        if (neighbor.isOnFire == false)
                        {
                            flammables.Add(neighbor); //Add it to the list of things that could catch fire
                        }
                    }
                }

                //Spread to Neighbors
                if (flammables.Count > 0)
                {
                    int random = Random.Range(0, flammables.Count);
                    flammables[random].Ignite();
                }
            }
        }

        [Button("Extinguish")]
        public void Extinguish()
        {
            isOnFire = false;
            flames.SetActive(false);

            GameManager.Instance.AudioManager.Play("SteamExhaust", this.gameObject);
        }

        /// <summary>
        /// Returns the amount of damage mitigated by this cell's attributes (such as armor)
        /// </summary>
        /// <returns></returns>
        private float GetDamageMitigation(float damage)
        {
            return room.type == Room.RoomType.Armor ? damage / 2 : 0; //Armor currently mitigates half of all incoming damage
        }

        /// <summary>
        /// Initializes collision system for cell and attaches it to tread system.
        /// </summary>
        public void SetUpCollision()
        {
            //Generate clone:
            compositeClone = new GameObject(name + "_" + name + "_Collider").AddComponent<BoxCollider2D>(); //Create clone for cell (size does not need to be modified bc cell size = BoxCollider2D default size)
            compositeClone.gameObject.layer = LayerMask.NameToLayer("TankCollider");                        //Place clone on ground layer so it doesn't mess with player collision
            compositeClone.transform.parent = room.targetTank.treadSystem.colliderSystem;                   //Child collider object to treadSystem container
            compositeClone.transform.position = transform.position;                                         //Move collider to match position with cell
            compositeClone.transform.rotation = transform.rotation;                                         //Rotate collider to match rotation with cell

            //Set up transmission:
            CollisionTransmitter transmitter = compositeClone.gameObject.AddComponent<CollisionTransmitter>(); //Set up collision transmission so that clone collider can communicate with cell
            transmitter.target = gameObject;                                                                   //Give transmitter a reference to this cell's object so that it can be found when needed
            transmitter.collisionEnter += room.OnTankCollision;                                                //Hook up collision delegate so that impact events against the treadSystem are processed on this script
        }
        /// <summary>
        /// Removes and cleans up elements involved with tread system collision.
        /// </summary>
        public void CleanUpCollision()
        {
            if (compositeClone == null) return;                                                         //Do nothing if collision has not already been set up
            compositeClone.GetComponent<CollisionTransmitter>().collisionEnter -= room.OnTankCollision; //Unsubscribe from clone collision transmission
            Destroy(compositeClone.gameObject);                                                         //Fully delete composite clone object
            compositeClone = null;                                                                      //Clear reference to destroyed object
        }
    }
}
